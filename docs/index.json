[{"content":"En un intento por lograr que nuestros servicios sean más óptimos, performantes y veloces, con nuestro equipo en Pomelo decidimos comenzar a implentar Go en algunos de los microservicios dentro de nuestra arquitectura.\n¿Por que Go\n(Composing Structs) Embedded Structures in Golang In the Go programming language, Embedded Structures are a way to reuse a struct’s fields without having to inherit from it.\nhttps://www.geeksforgeeks.org/embedded-structures-in-golang/\nPromoted fields Fields that belong to an embedded struct can be accessed directly through the outer struct variable. So, we can say that the fields of the embedded struct are promoted to the outer struct, and thus they are called the promoted fields.\nWhy they say that Go is \u0026ldquo;cheaper\u0026rdquo; than other languages like Java? Compilation Speed: Go\u0026rsquo;s fast compilation times mean that developers can iterate and test their code rapidly. This speed of compilation can lead to shorter development cycles and reduce the cost of development.\nScalability: Go is known for its efficiency in handling concurrent tasks, thanks to goroutines and channels. This efficiency allows developers to build scalable applications that can handle high levels of concurrency without the need for extensive hardware resources. This scalability can translate into cost savings by optimizing server and infrastructure costs.\nEfficiency: Go\u0026rsquo;s runtime performance is often comparable to or better than languages like Java. Efficient code execution can lead to cost savings in terms of hardware and cloud computing resources, as less computing power is needed to achieve the same results.\nGo is not (a traditional) object-oriented language\nhttps://chat.openai.com/share/cbe5cd1d-53cd-41f7-abb7-a05f382af10c\nhttps://medium.com/@yesnandam/why-golang-choose-composition-as-its-base-rather-than-inheritance-1225d22a4798 https://medium.com/geekculture/why-golang-is-a-better-choice-for-your-next-project-8d042a77a30f https://www.bairesdev.com/blog/why-golang-is-so-fast-performance-analysis/\nThe Art of Enbugging, Andy Hunt and Dave Thomas (2003). ","permalink":"https://lmitelman.github.io/posts/lets-go/","summary":"En un intento por lograr que nuestros servicios sean más óptimos, performantes y veloces, con nuestro equipo en Pomelo decidimos comenzar a implentar Go en algunos de los microservicios dentro de nuestra arquitectura.\n¿Por que Go\n(Composing Structs) Embedded Structures in Golang In the Go programming language, Embedded Structures are a way to reuse a struct’s fields without having to inherit from it.\nhttps://www.geeksforgeeks.org/embedded-structures-in-golang/\nPromoted fields Fields that belong to an embedded struct can be accessed directly through the outer struct variable.","title":"Let's Go"},{"content":"https://martinfowler.com/articles/preparatory-refactoring-example.html https://brewhouse.io/blog/2014/11/10/healthy-codebase-and-preparatory-refactoring.html\nThe Art of Enbugging, Andy Hunt and Dave Thomas (2003). ","permalink":"https://lmitelman.github.io/posts/preparatory-refactoring/","summary":"https://martinfowler.com/articles/preparatory-refactoring-example.html https://brewhouse.io/blog/2014/11/10/healthy-codebase-and-preparatory-refactoring.html\nThe Art of Enbugging, Andy Hunt and Dave Thomas (2003). ","title":"Preparatory Refactoring"},{"content":"A few weeks ago, one of the best engineers on my team made an important comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\n— The great Fer.\nLet\u0026rsquo;s delve into this concept a bit\u0026hellip;\nIn object-oriented software, a typical use case involves executing logic based on an object\u0026rsquo;s internal state. For instance, consider a scenario where we want to sound an alarm if a thermometer reaches a certain temperature:\nclass Thermometer { private temperature: number = 0; increaseTemperature(value: number): void { this.temperature += value; } getTemperature(): number { return this.temperature; } }; class Alarm { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; In this \u0026ldquo;asking\u0026rdquo; approach, to detect the temperature and sound an alarm, we would have to:\nconst thermometer = new Thermometer(); thermometer.increaseTemperature(35); const temperature = thermometer.getTemperature(); if (temperature \u0026gt; 30) { const alarm = new Alarm(); alarm.sound(); }; However, following the Tell-Don\u0026rsquo;t-Ask principle suggests that the logic should reside within the object itself if it is related to that object. In other words, the thermometer should be responsible for sounding the alarm when it reaches a certain temperature. This promotes more object-oriented code as opposed to procedural code.\nProcedural code gets information then makes decisions. Object-oriented code tells objects to do things.\nWith this in mind, let\u0026rsquo;s refactor our classes using a \u0026ldquo;telling\u0026rdquo; approach:\nclass Thermometer { private temperature: number = 0; private alarm: Alarm; constructor(alarm: Alarm) { this.alarm = alarm; } increaseTemperature(value: number): void { this.temperature += value; if (this.temperature \u0026gt; 30) { this.alarm.sound(); } } }; class Alarm { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; Now, instead of checking the thermometer\u0026rsquo;s internal status to sound the alarm, we \u0026ldquo;tell\u0026rdquo; the thermometer to handle that:\nconst alarm = new Alarm(); const thermometer = new Thermometer(alarm); thermometer.increaseTemperature(35); To summarize, it is acceptable to \u0026ldquo;ask\u0026rdquo; for the state of an object and then execute certain logic based on that information. However, if that logic is inherently related to the object, it should be moved and become the responsibility of the object itself. By adhering to the Tell-Don\u0026rsquo;t-Ask principle, we can create more maintainable and object-oriented code.\nThe Art of Enbugging, Andy Hunt and Dave Thomas (2003). ","permalink":"https://lmitelman.github.io/posts/tell-dont-ask/","summary":"A few weeks ago, one of the best engineers on my team made an important comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\n— The great Fer.\nLet\u0026rsquo;s delve into this concept a bit\u0026hellip;\nIn object-oriented software, a typical use case involves executing logic based on an object\u0026rsquo;s internal state. For instance, consider a scenario where we want to sound an alarm if a thermometer reaches a certain temperature:","title":"Tell-Don’t-Ask"}]