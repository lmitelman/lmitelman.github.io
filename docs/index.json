[{"content":"A few weeks ago, one of the best engineers on my team made an important comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\n— Fernando Balmaceda, the great.\nLet\u0026rsquo;s delve into this concept a bit\u0026hellip;\nIn object-oriented software, a typical use case involves executing logic based on an object\u0026rsquo;s internal state. For instance, consider a scenario where we want to sound an alarm if a thermometer reaches a certain temperature:\nclass Thermometer { private temperature: number = 0; increaseTemperature(value: number): void { this.temperature += value; } getTemperature(): number { return this.temperature; } }; class Alarm { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; In this \u0026ldquo;asking\u0026rdquo; approach, to detect the temperature and sound an alarm, we would have to:\nconst thermometer = new Thermometer(); thermometer.increaseTemperature(35); const temperature = thermometer.getTemperature(); if (temperature \u0026gt; 30) { const alarm = new Alarm(); alarm.sound(); }; However, following the Tell-Don\u0026rsquo;t-Ask principle suggests that the logic should reside within the object itself if it is related to that object. In other words, the thermometer should be responsible for sounding the alarm when it reaches a certain temperature. This promotes more object-oriented code as opposed to procedural code.\nProcedural code gets information then makes decisions. Object-oriented code tells objects to do things.\nWith this in mind, let\u0026rsquo;s refactor our classes using a \u0026ldquo;telling\u0026rdquo; approach:\nclass Thermometer { private temperature: number = 0; private alarm: Alarm; constructor(alarm: Alarm) { this.alarm = alarm; } increaseTemperature(value: number): void { this.temperature += value; if (this.temperature \u0026gt; 30) { this.alarm.sound(); } } }; class Alarm { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; Now, instead of checking the thermometer\u0026rsquo;s internal status to sound the alarm, we \u0026ldquo;tell\u0026rdquo; the thermometer to handle that:\nconst alarm = new Alarm(); const thermometer = new Thermometer(alarm); thermometer.increaseTemperature(35); To summarize, it is acceptable to \u0026ldquo;ask\u0026rdquo; for the state of an object and then execute certain logic based on that information. However, if that logic is inherently related to the object, it should be moved and become the responsibility of the object itself. By adhering to the Tell-Don\u0026rsquo;t-Ask principle, we can create more maintainable and object-oriented code.\nAcknowledgements I would like to extend my heartfelt thanks to Fernando Balmaceda, whose comment sparked the idea for this post. His contributions and mentorship have played a significant role in shaping my approach to software engineering. \u0026ldquo;The Art of Enbugging\u0026rdquo; by Andy Hunt and Dave Thomas (2003). ","permalink":"https://lmitelman.github.io/posts/tell-dont-ask/","summary":"A few weeks ago, one of the best engineers on my team made an important comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\n— Fernando Balmaceda, the great.\nLet\u0026rsquo;s delve into this concept a bit\u0026hellip;\nIn object-oriented software, a typical use case involves executing logic based on an object\u0026rsquo;s internal state. For instance, consider a scenario where we want to sound an alarm if a thermometer reaches a certain temperature:","title":"Tell-Don’t-Ask"}]