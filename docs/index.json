[{"content":"https://shareg.pt/voKuLY5 Domain-Driven Design Quickly, Abel Avram and Floyd Marinescu (2007). ","permalink":"https://lmitelman.github.io/posts/generics/","summary":"https://shareg.pt/voKuLY5 Domain-Driven Design Quickly, Abel Avram and Floyd Marinescu (2007). ","title":"Generics"},{"content":"To raise our technical standards, with my teammates we decided to go back to basics for a few weeks. Under the wings of my great colleagues Fer and Cesar, our goal was to reinforce the fundamentals of Domain Driven Design.\nAs you have read in the title, today we will explore two important design patterns to transfer data between different layers of an application: Entities, Data Transfer Objects and Value Objects.\n\u0026ldquo;If you can’t rederive concepts from the basics as you need them, you’re lost.\u0026rdquo;\nhttps://sharegpt.com/c/x25sNIb https://sharegpt.com/c/IE17oX8\nWhat is an Entity? What is a DTO? A Data Transfer Object (DTO) is a data structure that is used to represent the data of an object in an application, without having any behavior or logic associated with it.\nFor example, if a user\u0026rsquo;s information needs to be passed from a web application\u0026rsquo;s frontend to its backend, a User DTO could be used to represent the user\u0026rsquo;s data in a consistent and easy-to-use format.\nclass User { constructor( public id: number, public firstName: string, public lastName: string, public email: string, ) {} } What is a Value Object? On the other hand, a Value Object is a type of object that is defined by its value, rather than by its identity. Value Objects can be used in many different ways, but one common use case is to represent data that is expected to be consistent and immutable.\nWhen should you use it?\nDomain-Driven Design Quickly, Abel Avram and Floyd Marinescu (2007). ","permalink":"https://lmitelman.github.io/posts/dto-vs-vo/","summary":"To raise our technical standards, with my teammates we decided to go back to basics for a few weeks. Under the wings of my great colleagues Fer and Cesar, our goal was to reinforce the fundamentals of Domain Driven Design.\nAs you have read in the title, today we will explore two important design patterns to transfer data between different layers of an application: Entities, Data Transfer Objects and Value Objects.","title":"Entities, DTOs and Value Objects"},{"content":"A few weeks ago one of the best engineers in my team, the great Fer, made a comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\nLet\u0026rsquo;s talk a bit about this\u0026hellip;\nIn object-oriented software, a typical use case is to execute logic based on an object\u0026rsquo;s internal state. For example, sounding an alarm in case our thermometer reaches a certain temperature:\nclass Thermometer() { private temperature: number = 0; increaseTemperature(value: number): void { this.temperature = this.temperature + value; } askTemperature(): number { return this.temperature; } }; class Alarm() { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; With this \u0026ldquo;asking\u0026rdquo; approach, to detect the temperature and sound an alarm, we should:\nconst thermometer = new Thermometer(); thermometer.increaseTemperature(35); const temperature = thermometer.askTemperature(); if (temperature \u0026gt; 30) { const alarm = new Alarm(); alarm.sound(); }; If you are doing this, chances are that the logic you are implementing should be the object\u0026rsquo;s responsibility. It is very likely that our thermometer should be in charge of sounding the alarm in case of reaching a certain temperature.\nProcedural code gets information then makes decisions. Object-oriented code tells objects to do things.\nSo, let\u0026rsquo;s refactor our classes with a \u0026ldquo;telling\u0026rdquo; approach\u0026hellip;\nclass Thermometer() { private temperature: number = 0; private alarm: Alarm; constructor(alarm: Alarm) { this.alarm = alarm; } increaseTemperature(value: number): void { this.temperature = this.temperature + value; if (this.temperature \u0026gt; 30) { this.alarm.sound(); }; } }; class Alarm() { sound(): void { console.log(\u0026#39;RIIING!\u0026#39;); } }; Now, instead of us checking the thermometer\u0026rsquo;s internal status to sound the alarm, we \u0026ldquo;tell\u0026rdquo; him to do that:\nconst alarm = new Alarm(); const thermometer = new Thermometer(alarm); thermometer.increaseTemperature(35); In conclusion, it is correct to \u0026ldquo;ask\u0026rdquo; for the state of an object and then execute a certain logic. However, if that logic is related to the object, it may need to be moved and be the responsibility of the object itself.\nThe Art of Enbugging, Andy Hunt and Dave Thomas (2003). ","permalink":"https://lmitelman.github.io/posts/tell-dont-ask/","summary":"A few weeks ago one of the best engineers in my team, the great Fer, made a comment in a pull request:\n\u0026ldquo;Remember not to break the Tell-Don\u0026rsquo;t-Ask principle.\u0026rdquo;\nLet\u0026rsquo;s talk a bit about this\u0026hellip;\nIn object-oriented software, a typical use case is to execute logic based on an object\u0026rsquo;s internal state. For example, sounding an alarm in case our thermometer reaches a certain temperature:\nclass Thermometer() { private temperature: number = 0; increaseTemperature(value: number): void { this.","title":"Tell-Don’t-Ask"}]